LC78 子集
-------------------------------------------------------
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：
输入：nums = [0]
输出：[[],[0]]

提示：
1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同
-----------------------------------------------------------
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List:
        res = [[]]
        for i in range(len(nums)):
                for j in range(len(res)):
                    res.append(res[j]+[nums[i]])
                    print(f"i={i}")
                    print(f"len_nums={len(nums)}")
                    print(f"j={j}")
                    print(f"len_res={len(res)}")
                    print(res)
        return res

if __name__ == "__main__":
    solu = Solution()
    nums = [1, 2, 3]
    res = [[]]
    res = solu.subsets(nums)

    print("----------------------")
    print(res)
------执行结果-------
# python3 subset-10-1.py
i=0
len_nums=3
j=0
len_res=2
[[], [1]]
i=1
len_nums=3
j=0
len_res=3
[[], [1], [2]]
i=1
len_nums=3
j=1
len_res=4
[[], [1], [2], [1, 2]]
i=2
len_nums=3
j=0
len_res=5
[[], [1], [2], [1, 2], [3]]
i=2
len_nums=3
j=1
len_res=6
[[], [1], [2], [1, 2], [3], [1, 3]]
i=2
len_nums=3
j=2
len_res=7
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3]]
i=2
len_nums=3
j=3
len_res=8
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
----------------------
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

-------------------------------------------------------
46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：
输入：nums = [1]
输出：[[1]]

from typing import List
class Solution:
    def subset(self, nums:List[int])-> list:
        def backtrack(start):
            if start == len(nums):
                res.append(nums[:])
                return

            for i in range(start, len(nums)):
                nums[start], nums[i] = nums[i], nums[start]      # 交换元素
                backtrack(start + 1)                             # 递归处理下一个
                nums[start], nums[i] = nums[i], nums[start]      # 恢复交换

        res = []
        backtrack(0)
        return res

if __name__ == "__main__":
    nums = [1,2,3,4]
    result = [[]]

    solu = Solution()
    result = solu.subset(nums)

    print(result)
-------------------------------------------------------
39. 组合总和
给你一个无重复元素的整数数组 candidates 和一个目标整数target，
找出 candidates 中可以使数字和为目标数 target 的 所有不同组合，并以列表形式返回。
你可以按任意顺序 返回这些组合。
candidates中的同一个数字可以无限制重复被选取。
如果至少一个数字的被选数量不同，则两种组合是不同的。 
对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意2 可以使用多次。
7 也是一个候选， 7 = 7。
仅有这两种组合。

示例 2：
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]

示例 3：
输入: candidates = [2], target = 1
输出: []
----------
from typing import List
class Solution:
    def combinationSum(self, candidates:List[int], target:int)-> List[int]:
        """
        组合总和问题解法（回溯算法）
        :param candidates: 无重复元素的整数数组
        :param target: 目标整数
        :return: 所有可能的组合列表
        """
        res = []  # 存储最终结果

        def backtrack(start, path, remaining):
            """
            回溯核心函数
            :param start: 当前候选数的起始索引（避免重复组合）
            :param path: 当前组合路径
            :param remaining: 距离目标值的剩余量
            """
            # 终止条件1：剩余量为0时记录有效组合
            if remaining == 0:
                res.append(path.copy())  # 注意要用copy避免后续修改影响
                return

            # 终止条件2：剩余量小于0时剪枝
            if remaining < 0:
                return

            # 遍历候选数（从start开始避免重复组合）
            for i in range(start, len(candidates)):
                num = candidates[i]
                path.append(num)  # 选择当前数
                # 关键点：允许重复选择，所以下一轮仍从i开始
                backtrack(i, path, remaining - num)
                path.pop()  # 撤销选择（回溯）

        backtrack(0, [], target)  # 初始调用
        return res
# 示例测试
#print(combinationSum([2,3,6,7], 7))  # 输出: [[2,2,3],[7]]
#print(combinationSum([2,3,5], 8))    # 输出: [[2,2,2,2],[2,3,3],[3,5]]

if __name__ == "__main__":
    candidates = [2,3,6,7]
    target = 7
    candidates = [2,3,5]
    target = 8
#    candidates = [2]
#    target = 1
    solu = Solution()
    result = solu.combinationSum( candidates, target)
    print(result)
-------------------------------------------------------
79. 单词搜索
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：
输入：board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCCED"
输出：true

示例 2：
输入：board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "SEE"
输出：true

示例 3：
输入：board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCB"
输出：false
-----------
from typing import List
class Solution:
    def isExisted(self, board:List[List[str]], word:str) -> bool:
        def search(i:int, j:int, k:int, visted:set )-> bool:
            if k == len(word):
                return True
            if (i < 0 or i>= len(board) or j < 0 or j >= len(board[0]) or (i, j) in visted or board[i][j] != word[k]) :
                return False
            visted.add((i,j))
            res = (search(i,j+1,k+1,visted) or
                   search(i+1,j,k+1,visted) or
                   search(i,j-1,k+1,visted) or
                   search(i-1,j,k+1,visted))
            visted.remove((i,j))
            return res
        high = len(board)
        length = len(board[0])
        for i in range(high):
            for j in range(length):
                if search(i, j, 0, set()):
                    return True
        return False

if __name__ == "__main__":
    board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]
    word = "ABCCED"

    board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]
    word = "SEE"

    board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]
    word = "ABCB"

    solu = Solution()
    result =solu.isExisted(board, word)
    print(result)
-------------------------------------------------------
967. 连续差相同的数字
中等
返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。
请注意，除了 数字 0 本身之外，答案中的每个数字都 不能 有前导零。例如，01 有一个前导零，所以是无效的；但 0 是有效的。
你可以按 任何顺序 返回答案。

示例 1：
输入：n = 3, k = 7
输出：[181,292,707,818,929]
解释：注意，070 不是一个有效的数字，因为它有前导零。

示例 2：
输入：n = 2, k = 1
输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]

示例 3：
输入：n = 2, k = 0
输出：[11,22,33,44,55,66,77,88,99]

示例 4：
输入：n = 2, k = 2
输出：[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]
---------
from typing import List
class Solution:
    def numsSameConsecDiff(self, n:int, k:int) -> List[int]:
        if n == 1:
            return [i for i in range(10)]

        result = []

        def backtrack(current:List[int], remaining:int):
            if remaining == 0:
                result.append(int(''.join(map(str, current))))
                return

            last_digit = current[-1]
            next_digits = set([last_digit + k, last_digit - k])

            for digit in next_digits:
                if 0 <= digit <= 9:
                    backtrack(current + [digit], remaining - 1)

        for first_digit in range(1, 10):
            backtrack([first_digit], n - 1)

        return result

if __name__ == "__main__":
    solu = Solution()
    n = 3
    k = 7

    result = []
    result = solu.numsSameConsecDiff(n,k)
    print(result)
-------------------------------------------------------

-------------------------------------------------------
