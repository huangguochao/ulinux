LC78 子集
-------------------------------------------------------
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

示例 2：
输入：nums = [0]
输出：[[],[0]]

提示：
1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同
-----------------------------------------------------------
from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List:
        res = [[]]
        for i in range(len(nums)):
                for j in range(len(res)):
                    res.append(res[j]+[nums[i]])
                    print(f"i={i}")
                    print(f"len_nums={len(nums)}")
                    print(f"j={j}")
                    print(f"len_res={len(res)}")
                    print(res)
        return res

if __name__ == "__main__":
    solu = Solution()
    nums = [1, 2, 3]
    res = [[]]
    res = solu.subsets(nums)

    print("----------------------")
    print(res)
------执行结果-------
# python3 subset-10-1.py
i=0
len_nums=3
j=0
len_res=2
[[], [1]]
i=1
len_nums=3
j=0
len_res=3
[[], [1], [2]]
i=1
len_nums=3
j=1
len_res=4
[[], [1], [2], [1, 2]]
i=2
len_nums=3
j=0
len_res=5
[[], [1], [2], [1, 2], [3]]
i=2
len_nums=3
j=1
len_res=6
[[], [1], [2], [1, 2], [3], [1, 3]]
i=2
len_nums=3
j=2
len_res=7
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3]]
i=2
len_nums=3
j=3
len_res=8
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
----------------------
[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]

-------------------------------------------------------
46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：
输入：nums = [1]
输出：[[1]]

from typing import List
class Solution:
    def subset(self, nums:List[int])-> list:
        def backtrack(start):
            if start == len(nums):
                res.append(nums[:])
                return

            for i in range(start, len(nums)):
                nums[start], nums[i] = nums[i], nums[start]      # 交换元素
                backtrack(start + 1)                             # 递归处理下一个
                nums[start], nums[i] = nums[i], nums[start]      # 恢复交换

        res = []
        backtrack(0)
        return res

if __name__ == "__main__":
    nums = [1,2,3,4]
    result = [[]]

    solu = Solution()
    result = solu.subset(nums)

    print(result)
-------------------------------------------------------
39. 组合总和
给你一个无重复元素的整数数组 candidates 和一个目标整数target，
找出 candidates 中可以使数字和为目标数 target 的 所有不同组合，并以列表形式返回。
你可以按任意顺序 返回这些组合。
candidates中的同一个数字可以无限制重复被选取。
如果至少一个数字的被选数量不同，则两种组合是不同的。 
对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意2 可以使用多次。
7 也是一个候选， 7 = 7。
仅有这两种组合。

示例 2：
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]

示例 3：
输入: candidates = [2], target = 1
输出: []
-------------------------------------------------------
