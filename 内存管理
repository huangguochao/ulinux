核心概念关系总览
你可以将它们想象成一个仓库管理系统：

Node (NUMA节点): 整个仓库大楼。如果公司有多个异地仓库（多颗物理CPU），这就是为了减少“运输距离”（内存访问延迟）。
Zone (内存区域): 大楼里的不同库区，比如普通货架区、小型货物专用区、只能由特定货车装卸的货区。划分原因是物理内存本身的特性或硬件限制。
DMA Zone 就是那个只能由特定老旧货车（DMA设备）装卸的货区，因为老货车只能开到仓库的低地址区域。
Page (页): 库区里的标准货架。这是内存管理的基本单位，通常是4KB大小。
Slab (slab分配器): 放在标准货架上的收纳盒。为了高效管理小件货物（小内存对象），避免为每个小件都分配一个整个货架（页）造成浪费。

1. 内存架构层次：Node -> Zone -> Page
这是一个自上而下的层级关系：
物理内存 -> Node -> Zone -> Page Frame

a) Node (节点) - 最顶层结构
为什么需要？ 由于存在NUMA架构（非统一内存访问），一颗CPU访问直接连接自己的本地内存比访问另一颗CPU连接的内存要快。内核为了优化这种性能差异，将内存划分为不同的节点（Node）。
是什么？ 每个Node代表一块接近某个CPU的物理内存。在简单的UMA架构（如单CPU系统）中，只有一个node0。

b) Zone (区域) - 节点内的划分
每个Node中的内存又被划分为不同的Zone。划分的主要原因有：
硬件限制：一些老的DMA设备只能访问物理内存的低16MB或4GB以下地址。
内存本身的特性：有些内存页是永久保留的，有些是可移动的（为了对抗碎片化）。

主要的Zone类型：
ZONE_DMA:
目的：专供直接内存访问（DMA） 使用。因为一些老的ISA设备DMA控制器只有24位地址线，只能访问物理内存的前16MB空间。
范围： 0 ~ 16MB。

ZONE_DMA32:
目的：类似ZONE_DMA，但针对的是64位系统。一些32位的PCI设备只能访问4GB以下的物理内存。
范围： 0 ~ 4GB。

ZONE_NORMAL:
目的：内核线性映射区。这是内核最“普通”和主要的内存工作区域。内核无需特殊映射就可以直接访问这片内存（通过线性映射PAGE_OFFSET）。用户进程的内存也通过内核在这片区域分配后映射过去。
范围：在x86_32上，通常是16MB ~ 896MB。在64位系统上，由于地址空间巨大，它的范围可以很大（例如，从低地址开始到接近4GB或更高）。

ZONE_HIGHMEM:
目的：高端内存。仅在32位系统（地址空间4GB）中存在。因为32位内核需要将1GB或896MB的线性地址空间留给自身使用（映射ZONE_NORMAL和内核数据结构），无法直接映射所有物理内存。超出直接映射范围的物理内存就属于ZONE_HIGHMEM。内核访问它们需要动态创建临时映射。
范围：在x86_32上，通常是896MB ~ 结束。64位系统没有ZONE_HIGHMEM，因为它的虚拟地址空间巨大（128TB或更多），足以线性映射所有物理内存。

ZONE_MOVABLE:
目的：可移动区域。这是一个伪区域，其中的页可以被迁移（移动）。它本身不对应连续的物理内存，而是从其他Zone“借”来的。它的存在是为了帮助内核进行内存热插拔和对抗内存碎片。因为可移动的页被集中管理，碎片化就只发生在不可移动的页中，从而更容易整理出大块连续内存。

关系示意图（以64位系统为例，简化版）：
+------------------------------+
|         Node 0               |  // 一个NUMA节点
|  +-------------------------+ |
|  |       ZONE_DMA          | |  // 0 ~ 16MB
|  +-------------------------+ |
|  |      ZONE_DMA32         | |  // 16MB ~ 4GB
|  +-------------------------+ |
|  |      ZONE_NORMAL        | |  // 4GB ~ End（大部分内存在这里）
|  |                         | |
|  |  - [ZONE_MOVABLE]       | |  // 散布在ZONE_NORMAL中的可移动页
|  +-------------------------+ |
+------------------------------+

c) Page (页) / Page Frame - 基本单位
是什么？ 这是物理内存管理的最小单位。绝大多数系统的页大小是4KB。
如何管理？ 内核为每一个物理页都创建一个struct page结构体来描述它（称为页描述符）。所有这些结构体被存放在一个叫mem_map的数组中。通过页号（PFN）可以像数组下标一样索引到对应的struct page，从而管理该页的状态（是否空闲、谁在用、有多少引用等）。
与Zone的关系：每个Zone都管理着自己的一大片物理页。内核申请内存时，会指定从哪个Zone（或Zone列表）中分配页。

2. Slab分配器 - 基于Page的精细化管理者
为什么需要？ 内核自身需要频繁地分配和释放很多小块内存（例如task_struct, inode等对象）。如果每次都直接分配和释放一整个页（4KB），会产生大量内部碎片，效率极低。
是什么？ Slab分配器是一个建立在Page之上的缓存机制，专门用于高效分配和释放内核中的小对象。

如何工作？
缓存（Cache）： 每个内核数据结构（如task_struct）都有一个对应的Slab缓存。这个缓存被预先划分成一个个大小相等的对象。
Slab： 每个缓存由多个Slab构成。每个Slab本质上就是从一个或多个连续的Page中分配出来的一块内存，然后被切分成多个等大的对象。
对象（Object）： 就是最终分配给内核使用的那个小内存块。

与Page的关系：
Slab从Buddy System（伙伴系统，负责分配和回收整个页的子系统）那里申请到连续的物理页。
然后将这些页分割成小对象进行管理。
当Slab中的所有对象都被释放后，它可能会将占用的页返还给Buddy System。

------------------------------------------------------------------------------------------
当一个内核模块申请内存时，流程如下：
确定请求类型：申请的是用户内存还是内核内存？是大块内存（>=PAGE_SIZE）还是小对象？是否需要DMA？
选择路径：
申请大内存（以页为单位）：
调用alloc_pages()或类似接口。
内核的Buddy System会根据申请标志（如GFP_KERNEL, GFP_DMA）决定从哪个Node的哪个Zone中分配连续的物理页。
GFP_DMA标志会强制从ZONE_DMA分配。

申请小对象（如task_struct）：
调用kmalloc()或kmem_cache_alloc()。
Slab分配器会从对应的缓存（如task_struct cache）中找一个空闲对象。
如果缓存中没有空闲对象，Slab会向Buddy System申请新的页来创建一个新的Slab，然后从新Slab中分配对象给请求者。

关系流程图：

                    +---------------------+
                    |   内存申请请求        |
                    | (kmalloc/alloc_pages)|
                    +----------+----------+
                               |
                               v
                    +----------+----------+
                    |    GFP标志决定       | // 决定从哪个Zone分配
                    | (如 GFP_KERNEL, GFP_DMA)
                    +----------+----------+
                               |
                +--------------+---------------+
                |                              |
      +---------v---------+        +-----------v-----------+
      |   小对象申请        |        |      大内存申请        |
      |   (kmalloc等)      |        |    (alloc_pages等)    |
      +---------+---------+        +-----------+-----------+
                |                              |
                v                              v
      +---------+---------+        +-----------v-----------+
      |   Slab分配器       |        |     Buddy System      |
      |  (SLUB/SLAB)      |        |    (伙伴系统)         |
      +---------+---------+        +-----------+-----------+
                |                              |
                |  (需要时申请页)  +----------->+
                +------------------------------+
                               |
                               v
                    +----------+----------+
                    |   Zone分配器         | // 从特定Node的特定Zone分配页
                    | (ZONE_DMA/NORMAL等) |
                    +----------+----------+
                               |
                               v
                    +----------+----------+
                    |    物理页 Page       | // 最终的内存载体
                    +---------------------+
------------------------------------------------------------------------------------------
简单来说：

Node解决了“内存离哪个CPU近”的问题。
Zone解决了“内存有什么特殊用途”的问题（DMA，直接映射等）。
Page是管理内存的基本单元。
Slab是为了高效管理基于Page的小对象，避免浪费和提升效率。
------------------------------------------------------------------------------------------
