1. 互斥锁（Mutex）‌
‌原理‌：
线程获取锁失败时，主动让出 CPU 进入休眠状态（上下文切换），等待锁释放后被唤醒。
基于内核的 futex（快速用户空间互斥锁）实现，结合自旋和休眠机制。
‌代价‌：
上下文切换开销（约微秒级），不适用于高频短临界区。
‌适用场景‌：
临界区代码较长（>几微秒）、多线程竞争激烈、需避免 CPU 空转的场景（如 I/O 操作、复杂计算）。

‌2. 自旋锁（Spinlock）‌
‌原理‌：
线程通过 CAS（Compare-And-Swap）循环忙等待锁释放，不释放 CPU。
内核实现依赖原子指令（如 x86 的 LOCK 前缀）。
‌代价‌：
CPU 空转浪费资源，可能导致优先级反转问题。
‌适用场景‌：
临界区极短（<1μs）、多核环境且禁止休眠的场景（如中断处理、内核短临界区）。

‌3. 读写锁（Read-Write Lock）‌
‌原理‌：
允许多个读线程并发，写线程独占。通过计数器跟踪读线程数（例如 pthread_rwlock_t）。
‌代价‌：
锁内部维护复杂，写线程可能因持续读请求而"饿死"。
‌适用场景‌：
读多写少的数据结构（如配置缓存、数据库连接池）。

4. 顺序锁（Seqlock）‌
‌原理‌：
写操作通过递增序列号标记数据修改。读操作检查序列号变化，若变化则重试（无锁读取）。
内核实现示例：write_seqlock/write_sequnlock。
‌代价‌：
读操作可能重试多次，写操作需原子更新序列号。
‌适用场景‌：
高频读、极少写的场景（如系统时钟更新、统计计数器）。

‌5. RCU（Read-Copy-Update）‌
‌原理‌：
读操作无锁直接访问数据；写操作复制数据副本，修改后原子替换指针，延迟回收旧数据。
依赖"宽限期"（Grace Period）确保无读操作后再释放内存。
‌代价‌：
写操作内存开销大（需复制），回收延迟复杂。
‌适用场景‌：
极端读多写少、数据结构为指针的场景（如 Linux 路由表、内核链表）。

6. 信号量（Semaphore）‌
‌原理‌：
计数器控制资源访问，P()（获取资源）和 V()（释放资源）为原子操作。
支持多线程同时访问固定数量资源。
‌代价‌：
上下文切换开销类似互斥锁，但更灵活。
‌适用场景‌：
资源池限制（如线程池、数据库连接池）。

7. 文件锁（File Lock）‌
‌原理‌：
通过 fcntl() 系统调用实现进程间文件区域锁定（建议锁或强制锁）。
‌代价‌：
内核维护锁表，系统调用开销大。
‌适用场景‌：
多进程文件读写同步（如日志文件追加）。

锁类型‌	‌      竞争策略‌	      ‌    开销‌	            ‌最佳场景‌
‌自旋锁‌	      忙等待（CPU 空转）	低（无切换）	      纳秒级临界区、非抢占内核
‌互斥锁‌	      休眠等待	          高（上下文切换）  	微秒级以上临界区、用户态程序
‌读写锁‌	      读共享/写独占	    中等	            读多写少的数据访问
‌顺序锁‌	      读无锁/写同步	    读极低，写中等	    高频读、极少写（如时钟）
‌RCU‌	        读无锁/写复制	    读零开销，写极高	  海量读、极少写的指针数据结构
‌信号量‌	      计数器控制	        高（类似互斥锁）	  资源池限制
‌文件锁‌	      进程间同步	        极高（系统调用）	  多进程文件操作

选择建议‌
‌短临界区+多核‌     →   自旋锁
‌长临界区/用户态‌   →   互斥锁
‌读多写少‌         →   读写锁  或 RCU
‌极少写+高性能读‌   →   顺序锁  或 RCU
‌进程间同步‌       →   文件锁或信号量
